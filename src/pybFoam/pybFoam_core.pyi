"""
python bindings for openfoam
"""
from __future__ import annotations
import collections.abc
import numpy
import numpy.typing
import typing
__all__: list[str] = ['DictionaryGetOrDefaultProxy', 'DictionaryGetProxy', 'IOobject', 'Info', 'SolverScalarPerformance', 'SolverSymmTensorPerformance', 'SolverTensorPerformance', 'SolverVectorPerformance', 'SymmTensorInt', 'TensorInt', 'Time', 'VectorInt', 'Word', 'adjustPhi', 'argList', 'boolList', 'computeCFLNumber', 'computeContinuityErrors', 'constrainHbyA', 'constrainPressure', 'createMesh', 'createPhi', 'dictionary', 'dimAcceleration', 'dimArea', 'dimCurrent', 'dimDensity', 'dimEnergy', 'dimForce', 'dimLength', 'dimLuminousIntensity', 'dimMass', 'dimMoles', 'dimPower', 'dimPressure', 'dimTemperature', 'dimTime', 'dimVelocity', 'dimViscosity', 'dimensionSet', 'dimensionedScalar', 'dimensionedSymmTensor', 'dimensionedTensor', 'dimensionedVector', 'dimless', 'dynamicFvMesh', 'entry', 'faceList', 'fileName', 'fvBoundaryMesh', 'fvMesh', 'fvPatch', 'fvScalarMatrix', 'fvSymmTensorMatrix', 'fvTensorMatrix', 'fvVectorMatrix', 'instant', 'instantList', 'keyType', 'labelList', 'mag', 'pimpleControl', 'pisoControl', 'polyBoundaryMesh', 'polyMesh', 'polyPatch', 'scalarField', 'selectTimes', 'setRefCell', 'simpleControl', 'solve', 'sum', 'surfaceScalarField', 'surfaceSymmTensorField', 'surfaceTensorField', 'surfaceVectorField', 'symmTensor', 'symmTensorField', 'tensor', 'tensorField', 'tmp_fvScalarMatrix', 'tmp_fvSymmTensorMatrix', 'tmp_fvTensorMatrix', 'tmp_fvVectorMatrix', 'tmp_scalarField', 'tmp_surfaceScalarField', 'tmp_surfaceSymmTensorField', 'tmp_surfaceTensorField', 'tmp_surfaceVectorField', 'tmp_symmTensorField', 'tmp_tensorField', 'tmp_vectorField', 'tmp_volScalarField', 'tmp_volSymmTensorField', 'tmp_volTensorField', 'tmp_volVectorField', 'uniformDimensionedScalarField', 'uniformDimensionedVectorField', 'vector', 'vectorField', 'volScalarField', 'volSymmTensorField', 'volTensorField', 'volVectorField', 'wordList', 'write']
class DictionaryGetOrDefaultProxy:
    def __getitem__(self, arg0: typing.Any) -> typing.Any:
        ...
class DictionaryGetProxy:
    def __getitem__(self, arg0: typing.Any) -> typing.Any:
        ...
class IOobject:
    class readOption:
        """
        Members:
        
          NO_READ
        
          MUST_READ
        
          READ_IF_PRESENT
        """
        MUST_READ: typing.ClassVar[IOobject.readOption]  # value = <readOption.MUST_READ: 1>
        NO_READ: typing.ClassVar[IOobject.readOption]  # value = NO_READ
        READ_IF_PRESENT: typing.ClassVar[IOobject.readOption]  # value = <readOption.READ_IF_PRESENT: 4>
        __members__: typing.ClassVar[dict[str, IOobject.readOption]]  # value = {'NO_READ': NO_READ, 'MUST_READ': <readOption.MUST_READ: 1>, 'READ_IF_PRESENT': <readOption.READ_IF_PRESENT: 4>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: typing.SupportsInt) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: typing.SupportsInt) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class writeOption:
        """
        Members:
        
          NO_WRITE
        
          AUTO_WRITE
        """
        AUTO_WRITE: typing.ClassVar[IOobject.writeOption]  # value = <writeOption.AUTO_WRITE: 16>
        NO_WRITE: typing.ClassVar[IOobject.writeOption]  # value = NO_WRITE
        __members__: typing.ClassVar[dict[str, IOobject.writeOption]]  # value = {'NO_WRITE': NO_WRITE, 'AUTO_WRITE': <writeOption.AUTO_WRITE: 16>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: typing.SupportsInt) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: typing.SupportsInt) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    AUTO_WRITE: typing.ClassVar[IOobject.writeOption]  # value = <writeOption.AUTO_WRITE: 16>
    MUST_READ: typing.ClassVar[IOobject.readOption]  # value = <readOption.MUST_READ: 1>
    NO_READ: typing.ClassVar[IOobject.readOption]  # value = NO_READ
    NO_WRITE: typing.ClassVar[IOobject.writeOption]  # value = NO_WRITE
    READ_IF_PRESENT: typing.ClassVar[IOobject.readOption]  # value = <readOption.READ_IF_PRESENT: 4>
    def __init__(self, name: Word, instance: fileName, registry: Time, readOpt: IOobject.readOption = NO_READ, writeOpt: IOobject.writeOption = NO_WRITE) -> None:
        ...
class SolverScalarPerformance:
    def __init__(self) -> None:
        ...
    def converged(self) -> bool:
        ...
    def fieldName(self) -> Word:
        ...
    def finalResidual(self) -> float:
        ...
    def initialResidual(self) -> float:
        ...
    def nIterations(self) -> int:
        ...
    def singular(self) -> bool:
        ...
    def solverName(self) -> Word:
        ...
class SolverSymmTensorPerformance:
    def __init__(self) -> None:
        ...
    def converged(self) -> bool:
        ...
    def fieldName(self) -> Word:
        ...
    def finalResidual(self) -> symmTensor:
        ...
    def initialResidual(self) -> symmTensor:
        ...
    def nIterations(self) -> SymmTensorInt:
        ...
    def singular(self) -> bool:
        ...
    def solverName(self) -> Word:
        ...
class SolverTensorPerformance:
    def __init__(self) -> None:
        ...
    def converged(self) -> bool:
        ...
    def fieldName(self) -> Word:
        ...
    def finalResidual(self) -> tensor:
        ...
    def initialResidual(self) -> tensor:
        ...
    def nIterations(self) -> TensorInt:
        ...
    def singular(self) -> bool:
        ...
    def solverName(self) -> Word:
        ...
class SolverVectorPerformance:
    def __init__(self) -> None:
        ...
    def converged(self) -> bool:
        ...
    def fieldName(self) -> Word:
        ...
    def finalResidual(self) -> vector:
        ...
    def initialResidual(self) -> vector:
        ...
    def nIterations(self) -> VectorInt:
        ...
    def singular(self) -> bool:
        ...
    def solverName(self) -> Word:
        ...
class SymmTensorInt:
    def __getitem__(self, arg0: typing.SupportsInt) -> int:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
class TensorInt:
    def __getitem__(self, arg0: typing.SupportsInt) -> int:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
class Time:
    @typing.overload
    def __init__(self, arg0: Time) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str, arg1: str) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: argList) -> None:
        ...
    def deltaTValue(self) -> float:
        ...
    def increment(self) -> None:
        ...
    def loop(self) -> bool:
        ...
    def printExecutionTime(self) -> None:
        ...
    def run(self) -> bool:
        ...
    def setDeltaT(self, newDeltaT: typing.SupportsFloat) -> None:
        ...
    def setTime(self, arg0: instant, arg1: typing.SupportsInt) -> None:
        ...
    def timeName(self) -> Word:
        ...
    def value(self) -> float:
        ...
    def write(self, arg0: bool) -> bool:
        ...
class VectorInt:
    def __getitem__(self, arg0: typing.SupportsInt) -> int:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
class Word:
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, arg0: Word) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class argList:
    def __init__(self, arg0: collections.abc.Sequence[str]) -> None:
        ...
class boolList:
    def __getitem__(self, arg0: typing.SupportsInt) -> bool:
        ...
    @typing.overload
    def __init__(self, arg0: boolList) -> None:
        ...
    @typing.overload
    def __init__(self, vec: collections.abc.Sequence[bool]) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: bool) -> None:
        ...
    def list(self) -> list[bool]:
        ...
class dictionary:
    @staticmethod
    def read(arg0: str) -> dictionary:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: dictionary) -> None:
        ...
    @typing.overload
    def add(self, arg0: entry, arg1: bool) -> None:
        ...
    @typing.overload
    def add(self, key: str, value: Word) -> None:
        ...
    @typing.overload
    def add(self, arg0: str, arg1: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def add(self, arg0: str, arg1: vector) -> None:
        ...
    @typing.overload
    def add(self, arg0: str, arg1: tensor) -> None:
        ...
    @typing.overload
    def add(self, arg0: str, arg1: wordList) -> None:
        ...
    @typing.overload
    def add(self, arg0: str, arg1: scalarField) -> None:
        ...
    @typing.overload
    def add(self, arg0: str, arg1: vectorField) -> None:
        ...
    @typing.overload
    def add(self, arg0: str, arg1: tensorField) -> None:
        ...
    def clear(self) -> None:
        ...
    def found(self, arg0: str) -> bool:
        ...
    def get_scalar(self, arg0: str) -> float:
        ...
    def get_scalarField(self, arg0: str) -> scalarField:
        ...
    def get_tensor(self, arg0: str) -> tensor:
        ...
    def get_tensorField(self, arg0: str) -> tensorField:
        ...
    def get_vector(self, arg0: str) -> vector:
        ...
    def get_vectorField(self, arg0: str) -> vectorField:
        ...
    def get_word(self, arg0: str) -> Word:
        ...
    def get_wordList(self, arg0: str) -> wordList:
        ...
    def isDict(self, arg0: str) -> bool:
        ...
    def lookupSolverPerformanceScalarList(self, arg0: str) -> list[SolverScalarPerformance]:
        ...
    def lookupSolverPerformanceTensorList(self, arg0: str) -> list[SolverTensorPerformance]:
        ...
    def lookupSolverPerformanceVectorList(self, arg0: str) -> list[SolverVectorPerformance]:
        ...
    def print(self) -> None:
        ...
    @typing.overload
    def set(self, arg0: str, arg1: Word) -> None:
        ...
    @typing.overload
    def set(self, arg0: str, arg1: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def set(self, arg0: str, arg1: vector) -> None:
        ...
    @typing.overload
    def set(self, arg0: str, arg1: tensor) -> None:
        ...
    @typing.overload
    def set(self, arg0: str, arg1: wordList) -> None:
        ...
    @typing.overload
    def set(self, arg0: str, arg1: scalarField) -> None:
        ...
    @typing.overload
    def set(self, arg0: str, arg1: vectorField) -> None:
        ...
    @typing.overload
    def set(self, arg0: str, arg1: tensorField) -> None:
        ...
    def subDict(self, arg0: str) -> dictionary:
        ...
    def subDictOrAdd(self, arg0: str) -> dictionary:
        ...
    def toc(self) -> wordList:
        ...
    def write(self, arg0: str) -> None:
        ...
    @property
    def get(self) -> DictionaryGetProxy:
        ...
    @property
    def getOrDefault(self) -> DictionaryGetOrDefaultProxy:
        ...
class dimensionSet:
    def __and__(self, arg0: dimensionSet) -> dimensionSet:
        ...
    def __init__(self, arg0: typing.SupportsFloat, arg1: typing.SupportsFloat, arg2: typing.SupportsFloat, arg3: typing.SupportsFloat, arg4: typing.SupportsFloat, arg5: typing.SupportsFloat, arg6: typing.SupportsFloat) -> None:
        ...
    def __mul__(self, arg0: dimensionSet) -> dimensionSet:
        ...
    def __pow__(self, arg0: typing.SupportsFloat) -> dimensionSet:
        ...
    def __truediv__(self, arg0: dimensionSet) -> dimensionSet:
        ...
class dimensionedScalar:
    @typing.overload
    def __add__(self, field: volScalarField) -> tmp_volScalarField:
        """
        Add dimensioned value to volField
        """
    @typing.overload
    def __add__(self, field: tmp_volScalarField) -> tmp_volScalarField:
        """
        Add dimensioned value to tmp<volField>
        """
    @typing.overload
    def __init__(self, name: Word, dimensions: dimensionSet, value: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __init__(self, name: Word, dimensions: dimensionSet, dict: dictionary) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, dimensions: dimensionSet, value: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __mul__(self, field: volScalarField) -> tmp_volScalarField:
        """
        Multiply dimensioned value by volScalarField
        """
    @typing.overload
    def __mul__(self, field: tmp_volScalarField) -> tmp_volScalarField:
        """
        Multiply dimensioned value by tmp<volScalarField>
        """
    @typing.overload
    def __mul__(self, field: surfaceScalarField) -> tmp_surfaceScalarField:
        """
        Multiply dimensioned value by surfaceScalarField
        """
    @typing.overload
    def __mul__(self, field: tmp_surfaceScalarField) -> tmp_surfaceScalarField:
        """
        Multiply dimensioned value by tmp<surfaceScalarField>
        """
    @typing.overload
    def __mul__(self, arg0: volVectorField) -> tmp_volVectorField:
        """
        dimensioned × volVectorField
        """
    @typing.overload
    def __mul__(self, arg0: tmp_volVectorField) -> tmp_volVectorField:
        """
        dimensioned × tmp<volVectorField>
        """
    @typing.overload
    def __sub__(self, field: volScalarField) -> tmp_volScalarField:
        """
        Subtract volField from dimensioned value
        """
    @typing.overload
    def __sub__(self, field: tmp_volScalarField) -> tmp_volScalarField:
        """
        Subtract tmp<volField> from dimensioned value
        """
    def dimensions(self) -> dimensionSet:
        ...
    def name(self) -> str:
        ...
    def value(self) -> float:
        ...
class dimensionedSymmTensor:
    @typing.overload
    def __add__(self, field: volSymmTensorField) -> tmp_volSymmTensorField:
        """
        Add dimensioned value to volField
        """
    @typing.overload
    def __add__(self, field: tmp_volSymmTensorField) -> tmp_volSymmTensorField:
        """
        Add dimensioned value to tmp<volField>
        """
    @typing.overload
    def __init__(self, name: Word, dimensions: dimensionSet, value: symmTensor) -> None:
        ...
    @typing.overload
    def __init__(self, name: Word, dimensions: dimensionSet, dict: dictionary) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, dimensions: dimensionSet, value: symmTensor) -> None:
        ...
    @typing.overload
    def __mul__(self, field: volScalarField) -> tmp_volSymmTensorField:
        """
        Multiply dimensioned value by volScalarField
        """
    @typing.overload
    def __mul__(self, field: tmp_volScalarField) -> tmp_volSymmTensorField:
        """
        Multiply dimensioned value by tmp<volScalarField>
        """
    @typing.overload
    def __mul__(self, field: surfaceScalarField) -> tmp_surfaceSymmTensorField:
        """
        Multiply dimensioned value by surfaceScalarField
        """
    @typing.overload
    def __mul__(self, field: tmp_surfaceScalarField) -> tmp_surfaceSymmTensorField:
        """
        Multiply dimensioned value by tmp<surfaceScalarField>
        """
    @typing.overload
    def __sub__(self, field: volSymmTensorField) -> tmp_volSymmTensorField:
        """
        Subtract volField from dimensioned value
        """
    @typing.overload
    def __sub__(self, field: tmp_volSymmTensorField) -> tmp_volSymmTensorField:
        """
        Subtract tmp<volField> from dimensioned value
        """
    def dimensions(self) -> dimensionSet:
        ...
    def name(self) -> str:
        ...
    def value(self) -> symmTensor:
        ...
class dimensionedTensor:
    @typing.overload
    def __add__(self, field: volTensorField) -> tmp_volTensorField:
        """
        Add dimensioned value to volField
        """
    @typing.overload
    def __add__(self, field: tmp_volTensorField) -> tmp_volTensorField:
        """
        Add dimensioned value to tmp<volField>
        """
    @typing.overload
    def __init__(self, name: Word, dimensions: dimensionSet, value: tensor) -> None:
        ...
    @typing.overload
    def __init__(self, name: Word, dimensions: dimensionSet, dict: dictionary) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, dimensions: dimensionSet, value: tensor) -> None:
        ...
    @typing.overload
    def __mul__(self, field: volScalarField) -> tmp_volTensorField:
        """
        Multiply dimensioned value by volScalarField
        """
    @typing.overload
    def __mul__(self, field: tmp_volScalarField) -> tmp_volTensorField:
        """
        Multiply dimensioned value by tmp<volScalarField>
        """
    @typing.overload
    def __mul__(self, field: surfaceScalarField) -> tmp_surfaceTensorField:
        """
        Multiply dimensioned value by surfaceScalarField
        """
    @typing.overload
    def __mul__(self, field: tmp_surfaceScalarField) -> tmp_surfaceTensorField:
        """
        Multiply dimensioned value by tmp<surfaceScalarField>
        """
    @typing.overload
    def __sub__(self, field: volTensorField) -> tmp_volTensorField:
        """
        Subtract volField from dimensioned value
        """
    @typing.overload
    def __sub__(self, field: tmp_volTensorField) -> tmp_volTensorField:
        """
        Subtract tmp<volField> from dimensioned value
        """
    def dimensions(self) -> dimensionSet:
        ...
    def name(self) -> str:
        ...
    def value(self) -> tensor:
        ...
class dimensionedVector:
    @typing.overload
    def __add__(self, field: volVectorField) -> tmp_volVectorField:
        """
        Add dimensioned value to volField
        """
    @typing.overload
    def __add__(self, field: tmp_volVectorField) -> tmp_volVectorField:
        """
        Add dimensioned value to tmp<volField>
        """
    @typing.overload
    def __init__(self, name: Word, dimensions: dimensionSet, value: vector) -> None:
        ...
    @typing.overload
    def __init__(self, name: Word, dimensions: dimensionSet, dict: dictionary) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, dimensions: dimensionSet, value: vector) -> None:
        ...
    @typing.overload
    def __mul__(self, field: volScalarField) -> tmp_volVectorField:
        """
        Multiply dimensioned value by volScalarField
        """
    @typing.overload
    def __mul__(self, field: tmp_volScalarField) -> tmp_volVectorField:
        """
        Multiply dimensioned value by tmp<volScalarField>
        """
    @typing.overload
    def __mul__(self, field: surfaceScalarField) -> tmp_surfaceVectorField:
        """
        Multiply dimensioned value by surfaceScalarField
        """
    @typing.overload
    def __mul__(self, field: tmp_surfaceScalarField) -> tmp_surfaceVectorField:
        """
        Multiply dimensioned value by tmp<surfaceScalarField>
        """
    @typing.overload
    def __sub__(self, field: volVectorField) -> tmp_volVectorField:
        """
        Subtract volField from dimensioned value
        """
    @typing.overload
    def __sub__(self, field: tmp_volVectorField) -> tmp_volVectorField:
        """
        Subtract tmp<volField> from dimensioned value
        """
    def dimensions(self) -> dimensionSet:
        ...
    def name(self) -> str:
        ...
    def value(self) -> vector:
        ...
class dynamicFvMesh(fvMesh):
    @staticmethod
    def New(arg0: argList, arg1: Time) -> dynamicFvMesh:
        ...
    def controlledUpdateMesh(self) -> bool:
        ...
    def dynamic(self) -> bool:
        ...
    def updateMesh(self) -> bool:
        ...
class entry:
    pass
class faceList:
    @typing.overload
    def __init__(self, arg0: faceList) -> None:
        ...
    @typing.overload
    def __init__(self, faces: collections.abc.Sequence[collections.abc.Sequence[typing.SupportsInt]]) -> None:
        ...
class fileName:
    def __init__(self, arg0: str) -> None:
        ...
    def __str__(self) -> str:
        ...
class fvBoundaryMesh:
    def __getitem__(self, arg0: typing.SupportsInt) -> fvPatch:
        ...
    def __len__(self) -> int:
        ...
    def findPatchID(self, arg0: Word) -> int:
        ...
    def size(self) -> int:
        ...
class fvMesh:
    @staticmethod
    def fromPolyMesh(polyMesh: polyMesh, autoWrite: bool = False) -> fvMesh:
        """
        Create fvMesh from polyMesh by writing to disk and reading back
        """
    def C(self) -> volVectorField:
        ...
    def Cf(self) -> surfaceVectorField:
        ...
    def Sf(self) -> surfaceVectorField:
        ...
    def V(self) -> scalarField:
        ...
    @typing.overload
    def __init__(self, arg0: fvMesh) -> None:
        ...
    @typing.overload
    def __init__(self, time: Time, autoWrite: bool = False) -> None:
        ...
    def boundary(self) -> fvBoundaryMesh:
        ...
    def changing(self) -> bool:
        ...
    def magSf(self) -> surfaceScalarField:
        ...
    def nCells(self) -> int:
        ...
    def nFaces(self) -> int:
        ...
    def nInternalFaces(self) -> int:
        ...
    def nPoints(self) -> int:
        ...
    def setFluxRequired(self, arg0: Word) -> None:
        ...
    def solverPerformanceDict(self) -> dictionary:
        ...
    def time(self) -> Time:
        ...
    def write(self) -> bool:
        """
        Write mesh to disk
        """
class fvPatch:
    def index(self) -> int:
        ...
    def name(self) -> Word:
        ...
    def size(self) -> int:
        ...
    def start(self) -> int:
        ...
class fvScalarMatrix:
    def A(self) -> tmp_volScalarField:
        ...
    def D(self) -> tmp_scalarField:
        ...
    def H(self) -> tmp_volScalarField:
        ...
    def H1(self) -> tmp_volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: fvScalarMatrix) -> tmp_fvScalarMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_fvScalarMatrix) -> tmp_fvScalarMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volScalarField) -> tmp_fvScalarMatrix:
        ...
    @typing.overload
    def __init__(self, arg0: fvScalarMatrix) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_fvScalarMatrix) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: fvScalarMatrix) -> tmp_fvScalarMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_fvScalarMatrix) -> tmp_fvScalarMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volScalarField) -> tmp_fvScalarMatrix:
        ...
    def flux(self) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    def setReference(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat, arg2: bool) -> None:
        ...
    @typing.overload
    def solve(self) -> None:
        ...
    @typing.overload
    def solve(self, arg0: Word) -> None:
        ...
class fvSymmTensorMatrix:
    def A(self) -> tmp_volScalarField:
        ...
    def D(self) -> tmp_scalarField:
        ...
    def H(self) -> tmp_volSymmTensorField:
        ...
    def H1(self) -> tmp_volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: fvSymmTensorMatrix) -> tmp_fvSymmTensorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_fvSymmTensorMatrix) -> tmp_fvSymmTensorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volSymmTensorField) -> tmp_fvSymmTensorMatrix:
        ...
    @typing.overload
    def __init__(self, arg0: fvSymmTensorMatrix) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_fvSymmTensorMatrix) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: fvSymmTensorMatrix) -> tmp_fvSymmTensorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_fvSymmTensorMatrix) -> tmp_fvSymmTensorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volSymmTensorField) -> tmp_fvSymmTensorMatrix:
        ...
    def flux(self) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    def setReference(self, arg0: typing.SupportsInt, arg1: symmTensor, arg2: bool) -> None:
        ...
    @typing.overload
    def solve(self) -> None:
        ...
    @typing.overload
    def solve(self, arg0: Word) -> None:
        ...
class fvTensorMatrix:
    def A(self) -> tmp_volScalarField:
        ...
    def D(self) -> tmp_scalarField:
        ...
    def H(self) -> tmp_volTensorField:
        ...
    def H1(self) -> tmp_volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: fvTensorMatrix) -> tmp_fvTensorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_fvTensorMatrix) -> tmp_fvTensorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volTensorField) -> tmp_fvTensorMatrix:
        ...
    @typing.overload
    def __init__(self, arg0: fvTensorMatrix) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_fvTensorMatrix) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: fvTensorMatrix) -> tmp_fvTensorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_fvTensorMatrix) -> tmp_fvTensorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volTensorField) -> tmp_fvTensorMatrix:
        ...
    def flux(self) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    def setReference(self, arg0: typing.SupportsInt, arg1: tensor, arg2: bool) -> None:
        ...
    @typing.overload
    def solve(self) -> None:
        ...
    @typing.overload
    def solve(self, arg0: Word) -> None:
        ...
class fvVectorMatrix:
    def A(self) -> tmp_volScalarField:
        ...
    def D(self) -> tmp_scalarField:
        ...
    def H(self) -> tmp_volVectorField:
        ...
    def H1(self) -> tmp_volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: fvVectorMatrix) -> tmp_fvVectorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_fvVectorMatrix) -> tmp_fvVectorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volVectorField) -> tmp_fvVectorMatrix:
        ...
    @typing.overload
    def __init__(self, arg0: fvVectorMatrix) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_fvVectorMatrix) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: fvVectorMatrix) -> tmp_fvVectorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_fvVectorMatrix) -> tmp_fvVectorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volVectorField) -> tmp_fvVectorMatrix:
        ...
    def flux(self) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    def setReference(self, arg0: typing.SupportsInt, arg1: vector, arg2: bool) -> None:
        ...
    @typing.overload
    def solve(self) -> None:
        ...
    @typing.overload
    def solve(self, arg0: Word) -> None:
        ...
class instant:
    def __str__(self) -> str:
        ...
class instantList:
    def __getitem__(self, arg0: typing.SupportsInt) -> instant:
        ...
class keyType:
    @typing.overload
    def __init__(self, arg0: Word) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
class labelList:
    def __getitem__(self, arg0: typing.SupportsInt) -> int:
        ...
    @typing.overload
    def __init__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: labelList) -> None:
        ...
    @typing.overload
    def __init__(self, vec: collections.abc.Sequence[typing.SupportsInt]) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
    def list(self) -> list[int]:
        ...
class pimpleControl:
    def __init__(self, mesh: fvMesh, dictName: Word = ...) -> None:
        ...
    def correct(self) -> bool:
        ...
    def correctNonOrthogonal(self) -> bool:
        ...
    def finalInnerIter(self) -> bool:
        ...
    def finalIter(self) -> bool:
        ...
    def finalNonOrthogonalIter(self) -> bool:
        ...
    def loop(self) -> bool:
        ...
    def momentumPredictor(self) -> bool:
        ...
    def nNonOrthCorr(self) -> int:
        ...
    def turbCorr(self) -> bool:
        ...
class pisoControl:
    def __init__(self, mesh: fvMesh, dictName: Word = ...) -> None:
        ...
    def correct(self) -> bool:
        ...
    def correctNonOrthogonal(self) -> bool:
        ...
    def finalInnerIter(self) -> bool:
        ...
    def finalNonOrthogonalIter(self) -> bool:
        ...
    def momentumPredictor(self) -> bool:
        ...
    def nNonOrthCorr(self) -> int:
        ...
class polyBoundaryMesh:
    def __getitem__(self, arg0: typing.SupportsInt) -> polyPatch:
        ...
    def __len__(self) -> int:
        ...
    def findPatchID(self, arg0: Word) -> int:
        ...
    def size(self) -> int:
        ...
class polyMesh:
    @typing.overload
    def __init__(self, io: IOobject, points: vectorField, faces: faceList, owner: labelList, neighbour: labelList, syncPar: bool = True) -> None:
        """
        Create polyMesh from OpenFOAM types
        """
    @typing.overload
    def __init__(self, io: IOobject, points: collections.abc.Sequence[collections.abc.Sequence[typing.SupportsFloat]], faces: collections.abc.Sequence[collections.abc.Sequence[typing.SupportsInt]], owner: collections.abc.Sequence[typing.SupportsInt], neighbour: collections.abc.Sequence[typing.SupportsInt], syncPar: bool = True) -> None:
        """
        Create polyMesh from Python lists
        """
    @typing.overload
    def __init__(self, io: IOobject, points: collections.abc.Sequence[collections.abc.Sequence[typing.SupportsFloat]], cells: collections.abc.Sequence[tuple[str, collections.abc.Sequence[typing.SupportsInt]]], boundaryPatches: collections.abc.Sequence[tuple[str, collections.abc.Sequence[collections.abc.Sequence[typing.SupportsInt]]]], defaultPatchName: str = 'defaultFaces', syncPar: bool = True) -> None:
        """
        Create polyMesh from cellShapes (handles face orientation automatically)
        """
    def addPatches(self, patches: collections.abc.Sequence[polyPatch], validBoundary: bool = True) -> None:
        ...
    def boundaryMesh(self) -> polyBoundaryMesh:
        ...
    def faces(self) -> faceList:
        ...
    def facesInstance(self) -> fileName:
        ...
    def nCells(self) -> int:
        ...
    def nFaces(self) -> int:
        ...
    def nInternalFaces(self) -> int:
        ...
    def nPoints(self) -> int:
        ...
    def neighbour(self) -> labelList:
        ...
    def owner(self) -> labelList:
        ...
    def points(self) -> vectorField:
        ...
    def removeBoundary(self) -> None:
        """
        Remove boundary patches from mesh
        """
    def write(self) -> bool:
        ...
    @property
    def meshSubDir(self) -> Word:
        ...
class polyPatch:
    def __init__(self, name: Word, size: typing.SupportsInt, start: typing.SupportsInt, index: typing.SupportsInt, boundaryMesh: polyBoundaryMesh, patchType: Word) -> None:
        ...
    def name(self) -> Word:
        ...
    def size(self) -> int:
        ...
    def start(self) -> int:
        ...
    def type(self) -> Word:
        ...
class scalarField:
    @typing.overload
    def __add__(self, arg0: scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __add__(self, arg0: typing.SupportsFloat) -> tmp_scalarField:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    @typing.overload
    def __iadd__(self, arg0: scalarField) -> scalarField:
        ...
    @typing.overload
    def __iadd__(self, arg0: tmp_scalarField) -> scalarField:
        ...
    @typing.overload
    def __iadd__(self, arg0: typing.SupportsFloat) -> scalarField:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: scalarField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_scalarField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: collections.abc.Sequence[typing.SupportsFloat]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]) -> None:
        ...
    @typing.overload
    def __isub__(self, arg0: scalarField) -> scalarField:
        ...
    @typing.overload
    def __isub__(self, arg0: tmp_scalarField) -> scalarField:
        ...
    @typing.overload
    def __isub__(self, arg0: typing.SupportsFloat) -> scalarField:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_scalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_scalarField) -> tmp_scalarField:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: typing.SupportsFloat) -> tmp_scalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_scalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: tmp_scalarField) -> tmp_scalarField:
        ...
class simpleControl:
    def __init__(self, mesh: fvMesh, dictName: Word = ...) -> None:
        ...
    def correctNonOrthogonal(self) -> bool:
        ...
    def finalNonOrthogonalIter(self) -> bool:
        ...
    def loop(self) -> bool:
        ...
    def momentumPredictor(self) -> bool:
        ...
    def nNonOrthCorr(self) -> int:
        ...
class surfaceScalarField:
    @staticmethod
    def from_registry(arg0: fvMesh, arg1: str) -> surfaceScalarField:
        ...
    @staticmethod
    def list_objects(arg0: fvMesh) -> wordList:
        ...
    @staticmethod
    def read_field(arg0: fvMesh, arg1: str) -> surfaceScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedScalar) -> tmp_surfaceScalarField:
        ...
    def __getitem__(self, arg0: str) -> scalarField:
        ...
    @typing.overload
    def __init__(self, arg0: surfaceScalarField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_surfaceScalarField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Word, arg1: tmp_surfaceScalarField) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_surfaceScalarField:
        ...
    def __neg__(self) -> tmp_surfaceScalarField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceScalarField:
        ...
    def __setitem__(self, arg0: str, arg1: scalarField) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedScalar) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def assign(self, arg0: surfaceScalarField) -> None:
        ...
    @typing.overload
    def assign(self, arg0: tmp_surfaceScalarField) -> None:
        ...
    def correctBoundaryConditions(self) -> None:
        ...
    def internalField(self) -> scalarField:
        ...
    def mesh(self) -> fvMesh:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    def select(self, arg0: bool) -> Word:
        ...
class surfaceSymmTensorField:
    @staticmethod
    def from_registry(arg0: fvMesh, arg1: str) -> surfaceSymmTensorField:
        ...
    @staticmethod
    def list_objects(arg0: fvMesh) -> wordList:
        ...
    @staticmethod
    def read_field(arg0: fvMesh, arg1: str) -> surfaceSymmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: surfaceSymmTensorField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_surfaceSymmTensorField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedSymmTensor) -> tmp_surfaceSymmTensorField:
        ...
    def __getitem__(self, arg0: str) -> symmTensorField:
        ...
    @typing.overload
    def __init__(self, arg0: surfaceSymmTensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_surfaceSymmTensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Word, arg1: tmp_surfaceSymmTensorField) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: surfaceScalarField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_surfaceSymmTensorField:
        ...
    def __neg__(self) -> tmp_surfaceSymmTensorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceSymmTensorField:
        ...
    def __setitem__(self, arg0: str, arg1: symmTensorField) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: surfaceSymmTensorField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_surfaceSymmTensorField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedSymmTensor) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: surfaceScalarField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def assign(self, arg0: surfaceSymmTensorField) -> None:
        ...
    @typing.overload
    def assign(self, arg0: tmp_surfaceSymmTensorField) -> None:
        ...
    def correctBoundaryConditions(self) -> None:
        ...
    def internalField(self) -> symmTensorField:
        ...
    def mesh(self) -> fvMesh:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    def select(self, arg0: bool) -> Word:
        ...
class surfaceTensorField:
    @staticmethod
    def from_registry(arg0: fvMesh, arg1: str) -> surfaceTensorField:
        ...
    @staticmethod
    def list_objects(arg0: fvMesh) -> wordList:
        ...
    @staticmethod
    def read_field(arg0: fvMesh, arg1: str) -> surfaceTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: surfaceTensorField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_surfaceTensorField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedTensor) -> tmp_surfaceTensorField:
        ...
    def __getitem__(self, arg0: str) -> tensorField:
        ...
    @typing.overload
    def __init__(self, arg0: surfaceTensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_surfaceTensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Word, arg1: tmp_surfaceTensorField) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: surfaceScalarField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_surfaceTensorField:
        ...
    def __neg__(self) -> tmp_surfaceTensorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceTensorField:
        ...
    def __setitem__(self, arg0: str, arg1: tensorField) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: surfaceTensorField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_surfaceTensorField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedTensor) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: surfaceScalarField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def assign(self, arg0: surfaceTensorField) -> None:
        ...
    @typing.overload
    def assign(self, arg0: tmp_surfaceTensorField) -> None:
        ...
    def correctBoundaryConditions(self) -> None:
        ...
    def internalField(self) -> tensorField:
        ...
    def mesh(self) -> fvMesh:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    def select(self, arg0: bool) -> Word:
        ...
class surfaceVectorField:
    @staticmethod
    def from_registry(arg0: fvMesh, arg1: str) -> surfaceVectorField:
        ...
    @staticmethod
    def list_objects(arg0: fvMesh) -> wordList:
        ...
    @staticmethod
    def read_field(arg0: fvMesh, arg1: str) -> surfaceVectorField:
        ...
    @typing.overload
    def __add__(self, arg0: surfaceVectorField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_surfaceVectorField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedVector) -> tmp_surfaceVectorField:
        ...
    def __getitem__(self, arg0: str) -> vectorField:
        ...
    @typing.overload
    def __init__(self, arg0: surfaceVectorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_surfaceVectorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Word, arg1: tmp_surfaceVectorField) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: surfaceScalarField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_surfaceVectorField:
        ...
    def __neg__(self) -> tmp_surfaceVectorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceVectorField:
        ...
    def __setitem__(self, arg0: str, arg1: vectorField) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: surfaceVectorField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_surfaceVectorField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedVector) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: surfaceScalarField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def assign(self, arg0: surfaceVectorField) -> None:
        ...
    @typing.overload
    def assign(self, arg0: tmp_surfaceVectorField) -> None:
        ...
    def correctBoundaryConditions(self) -> None:
        ...
    def internalField(self) -> vectorField:
        ...
    def mesh(self) -> fvMesh:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    def select(self, arg0: bool) -> Word:
        ...
class symmTensor:
    def __add__(self, arg0: symmTensor) -> symmTensor:
        ...
    @typing.overload
    def __and__(self, arg0: symmTensor) -> tensor:
        ...
    @typing.overload
    def __and__(self, arg0: vector) -> vector:
        ...
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, arg0: symmTensor) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(6)"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.SupportsFloat, arg1: typing.SupportsFloat, arg2: typing.SupportsFloat, arg3: typing.SupportsFloat, arg4: typing.SupportsFloat, arg5: typing.SupportsFloat) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __mul__(self, arg0: typing.SupportsFloat) -> symmTensor:
        ...
    def __ne__(self, arg0: typing.Any) -> bool:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: symmTensor) -> symmTensor:
        ...
class symmTensorField:
    @typing.overload
    def __add__(self, arg0: symmTensorField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_symmTensorField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: symmTensor) -> tmp_symmTensorField:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> symmTensor:
        ...
    @typing.overload
    def __iadd__(self, arg0: symmTensorField) -> symmTensorField:
        ...
    @typing.overload
    def __iadd__(self, arg0: tmp_symmTensorField) -> symmTensorField:
        ...
    @typing.overload
    def __iadd__(self, arg0: symmTensor) -> symmTensorField:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: symmTensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_symmTensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: collections.abc.Sequence[symmTensor]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]) -> None:
        ...
    @typing.overload
    def __isub__(self, arg0: symmTensorField) -> symmTensorField:
        ...
    @typing.overload
    def __isub__(self, arg0: tmp_symmTensorField) -> symmTensorField:
        ...
    @typing.overload
    def __isub__(self, arg0: symmTensor) -> symmTensorField:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: scalarField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_scalarField) -> tmp_symmTensorField:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: symmTensor) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: symmTensorField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_symmTensorField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: symmTensor) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: scalarField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: tmp_scalarField) -> tmp_symmTensorField:
        ...
class tensor:
    def __add__(self, arg0: tensor) -> tensor:
        ...
    @typing.overload
    def __and__(self, arg0: tensor) -> tensor:
        ...
    @typing.overload
    def __and__(self, arg0: vector) -> vector:
        ...
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, arg0: tensor) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(9)"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.SupportsFloat, arg1: typing.SupportsFloat, arg2: typing.SupportsFloat, arg3: typing.SupportsFloat, arg4: typing.SupportsFloat, arg5: typing.SupportsFloat, arg6: typing.SupportsFloat, arg7: typing.SupportsFloat, arg8: typing.SupportsFloat) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __mul__(self, arg0: typing.SupportsFloat) -> tensor:
        ...
    def __ne__(self, arg0: typing.Any) -> bool:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: tensor) -> tensor:
        ...
class tensorField:
    @typing.overload
    def __add__(self, arg0: tensorField) -> tmp_tensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_tensorField) -> tmp_tensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tensor) -> tmp_tensorField:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> tensor:
        ...
    @typing.overload
    def __iadd__(self, arg0: tensorField) -> tensorField:
        ...
    @typing.overload
    def __iadd__(self, arg0: tmp_tensorField) -> tensorField:
        ...
    @typing.overload
    def __iadd__(self, arg0: tensor) -> tensorField:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_tensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: collections.abc.Sequence[tensor]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]) -> None:
        ...
    @typing.overload
    def __isub__(self, arg0: tensorField) -> tensorField:
        ...
    @typing.overload
    def __isub__(self, arg0: tmp_tensorField) -> tensorField:
        ...
    @typing.overload
    def __isub__(self, arg0: tensor) -> tensorField:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_tensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: scalarField) -> tmp_tensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_scalarField) -> tmp_tensorField:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: tensor) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: tensorField) -> tmp_tensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_tensorField) -> tmp_tensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tensor) -> tmp_tensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_tensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: scalarField) -> tmp_tensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: tmp_scalarField) -> tmp_tensorField:
        ...
class tmp_fvScalarMatrix:
    @typing.overload
    def __add__(self, arg0: tmp_fvScalarMatrix) -> tmp_fvScalarMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: fvScalarMatrix) -> tmp_fvScalarMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volScalarField) -> tmp_fvScalarMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_fvScalarMatrix) -> tmp_fvScalarMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: fvScalarMatrix) -> tmp_fvScalarMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volScalarField) -> tmp_fvScalarMatrix:
        ...
class tmp_fvSymmTensorMatrix:
    @typing.overload
    def __add__(self, arg0: tmp_fvSymmTensorMatrix) -> tmp_fvSymmTensorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: fvSymmTensorMatrix) -> tmp_fvSymmTensorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volSymmTensorField) -> tmp_fvSymmTensorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_fvSymmTensorMatrix) -> tmp_fvSymmTensorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: fvSymmTensorMatrix) -> tmp_fvSymmTensorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volSymmTensorField) -> tmp_fvSymmTensorMatrix:
        ...
class tmp_fvTensorMatrix:
    @typing.overload
    def __add__(self, arg0: tmp_fvTensorMatrix) -> tmp_fvTensorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: fvTensorMatrix) -> tmp_fvTensorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volTensorField) -> tmp_fvTensorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_fvTensorMatrix) -> tmp_fvTensorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: fvTensorMatrix) -> tmp_fvTensorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volTensorField) -> tmp_fvTensorMatrix:
        ...
class tmp_fvVectorMatrix:
    @typing.overload
    def __add__(self, arg0: tmp_fvVectorMatrix) -> tmp_fvVectorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: fvVectorMatrix) -> tmp_fvVectorMatrix:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volVectorField) -> tmp_fvVectorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_fvVectorMatrix) -> tmp_fvVectorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: fvVectorMatrix) -> tmp_fvVectorMatrix:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volVectorField) -> tmp_fvVectorMatrix:
        ...
class tmp_scalarField:
    @typing.overload
    def __add__(self, arg0: scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __add__(self, arg0: typing.SupportsFloat) -> tmp_scalarField:
        ...
    def __call__(self) -> scalarField:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_scalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_scalarField) -> tmp_scalarField:
        ...
    def __neg__(self) -> tmp_scalarField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_scalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: typing.SupportsFloat) -> tmp_scalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_scalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: scalarField) -> tmp_scalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: tmp_scalarField) -> tmp_scalarField:
        ...
class tmp_surfaceScalarField:
    @typing.overload
    def __add__(self, arg0: surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedScalar) -> tmp_surfaceScalarField:
        ...
    def __call__(self) -> surfaceScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_surfaceScalarField:
        ...
    def __neg__(self) -> tmp_surfaceScalarField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedScalar) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: surfaceScalarField) -> tmp_surfaceScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceScalarField:
        ...
class tmp_surfaceSymmTensorField:
    @typing.overload
    def __add__(self, arg0: surfaceSymmTensorField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_surfaceSymmTensorField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedSymmTensor) -> tmp_surfaceSymmTensorField:
        ...
    def __call__(self) -> surfaceSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: surfaceScalarField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_surfaceSymmTensorField:
        ...
    def __neg__(self) -> tmp_surfaceSymmTensorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: surfaceSymmTensorField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_surfaceSymmTensorField) -> tmp_surfaceSymmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedSymmTensor) -> tmp_surfaceSymmTensorField:
        ...
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_surfaceSymmTensorField:
        ...
class tmp_surfaceTensorField:
    @typing.overload
    def __add__(self, arg0: surfaceTensorField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_surfaceTensorField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedTensor) -> tmp_surfaceTensorField:
        ...
    def __call__(self) -> surfaceTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: surfaceScalarField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_surfaceTensorField:
        ...
    def __neg__(self) -> tmp_surfaceTensorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: surfaceTensorField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_surfaceTensorField) -> tmp_surfaceTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedTensor) -> tmp_surfaceTensorField:
        ...
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_surfaceTensorField:
        ...
class tmp_surfaceVectorField:
    @typing.overload
    def __add__(self, arg0: surfaceVectorField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_surfaceVectorField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedVector) -> tmp_surfaceVectorField:
        ...
    def __call__(self) -> surfaceVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: surfaceScalarField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_surfaceScalarField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_surfaceVectorField:
        ...
    def __neg__(self) -> tmp_surfaceVectorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: surfaceVectorField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_surfaceVectorField) -> tmp_surfaceVectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedVector) -> tmp_surfaceVectorField:
        ...
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_surfaceVectorField:
        ...
class tmp_symmTensorField:
    @typing.overload
    def __add__(self, arg0: symmTensorField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_symmTensorField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: symmTensor) -> tmp_symmTensorField:
        ...
    def __call__(self) -> symmTensorField:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> symmTensor:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: scalarField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_scalarField) -> tmp_symmTensorField:
        ...
    def __neg__(self) -> tmp_symmTensorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: symmTensorField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_symmTensorField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: symmTensor) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: scalarField) -> tmp_symmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: tmp_scalarField) -> tmp_symmTensorField:
        ...
class tmp_tensorField:
    @typing.overload
    def __add__(self, arg0: tensorField) -> tmp_tensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_tensorField) -> tmp_tensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tensor) -> tmp_tensorField:
        ...
    def __call__(self) -> tensorField:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> tensor:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_tensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: scalarField) -> tmp_tensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_scalarField) -> tmp_tensorField:
        ...
    def __neg__(self) -> tmp_tensorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_tensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tensorField) -> tmp_tensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_tensorField) -> tmp_tensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tensor) -> tmp_tensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_tensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: scalarField) -> tmp_tensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: tmp_scalarField) -> tmp_tensorField:
        ...
class tmp_vectorField:
    @typing.overload
    def __add__(self, arg0: vectorField) -> tmp_vectorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_vectorField) -> tmp_vectorField:
        ...
    @typing.overload
    def __add__(self, arg0: vector) -> tmp_vectorField:
        ...
    @typing.overload
    def __and__(self, arg0: vector) -> tmp_scalarField:
        ...
    @typing.overload
    def __and__(self, arg0: vectorField) -> tmp_scalarField:
        ...
    @typing.overload
    def __and__(self, arg0: tmp_vectorField) -> tmp_scalarField:
        ...
    def __call__(self) -> vectorField:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> vector:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_vectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: scalarField) -> tmp_vectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_scalarField) -> tmp_vectorField:
        ...
    def __neg__(self) -> tmp_vectorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_vectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: vectorField) -> tmp_vectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_vectorField) -> tmp_vectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: vector) -> tmp_vectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_vectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: scalarField) -> tmp_vectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: tmp_scalarField) -> tmp_vectorField:
        ...
class tmp_volScalarField:
    @typing.overload
    def __add__(self, arg0: volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedScalar) -> tmp_volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    def __call__(self) -> volScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_volScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: volVectorField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_volVectorField) -> tmp_volVectorField:
        ...
    def __neg__(self) -> tmp_volScalarField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    def __rtruediv__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedScalar) -> tmp_volScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_volScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: tmp_volScalarField) -> tmp_volScalarField:
        ...
class tmp_volSymmTensorField:
    @typing.overload
    def __add__(self, arg0: volSymmTensorField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volSymmTensorField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedSymmTensor) -> tmp_volSymmTensorField:
        ...
    def __call__(self) -> volSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: volScalarField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_volScalarField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_volSymmTensorField:
        ...
    def __neg__(self) -> tmp_volSymmTensorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: volSymmTensorField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volSymmTensorField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedSymmTensor) -> tmp_volSymmTensorField:
        ...
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_volSymmTensorField:
        ...
class tmp_volTensorField:
    @typing.overload
    def __add__(self, arg0: volTensorField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volTensorField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedTensor) -> tmp_volTensorField:
        ...
    def __call__(self) -> volTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: volScalarField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_volScalarField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_volTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_volTensorField:
        ...
    def __neg__(self) -> tmp_volTensorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_volTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: volTensorField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volTensorField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedTensor) -> tmp_volTensorField:
        ...
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_volTensorField:
        ...
class tmp_volVectorField:
    @typing.overload
    def __add__(self, arg0: volVectorField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volVectorField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedVector) -> tmp_volVectorField:
        ...
    def __call__(self) -> volVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: volScalarField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_volScalarField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_volVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_volVectorField:
        ...
    def __neg__(self) -> tmp_volVectorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_volVectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: volVectorField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volVectorField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedVector) -> tmp_volVectorField:
        ...
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_volVectorField:
        ...
class uniformDimensionedScalarField:
    def __init__(self, mesh: fvMesh, fieldName: str) -> None:
        """
        Read a uniformDimensionedScalarField from constant/ directory
        """
    def dimensions(self) -> dimensionSet:
        """
        Get the field dimensions
        """
    def name(self) -> Word:
        """
        Get the field name
        """
    def value(self) -> float:
        """
        Get the uniform scalar value
        """
class uniformDimensionedVectorField:
    @typing.overload
    def __and__(self, vf: volVectorField) -> tmp_volScalarField:
        """
        Dot product with volVectorField, returns tmp<volScalarField>
        """
    @typing.overload
    def __and__(self, vf: surfaceVectorField) -> tmp_surfaceScalarField:
        """
        Dot product with surfaceVectorField, returns tmp<surfaceScalarField>
        """
    def __init__(self, mesh: fvMesh, fieldName: str) -> None:
        """
        Read a uniformDimensionedVectorField from constant/ directory
        """
    def dimensions(self) -> dimensionSet:
        """
        Get the field dimensions
        """
    def name(self) -> Word:
        """
        Get the field name
        """
    def value(self) -> vector:
        """
        Get the uniform vector value
        """
class vector:
    def __add__(self, arg0: vector) -> vector:
        ...
    @typing.overload
    def __and__(self, arg0: vector) -> float:
        ...
    @typing.overload
    def __and__(self, arg0: tensor) -> vector:
        ...
    @typing.overload
    def __and__(self, arg0: symmTensor) -> vector:
        ...
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> float:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, arg0: vector) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], "FixedSize(3)"]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.SupportsFloat, arg1: typing.SupportsFloat, arg2: typing.SupportsFloat) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __mul__(self, arg0: typing.SupportsFloat) -> vector:
        ...
    def __ne__(self, arg0: typing.Any) -> bool:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: typing.SupportsFloat) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: vector) -> vector:
        ...
class vectorField:
    @typing.overload
    def __add__(self, arg0: vectorField) -> tmp_vectorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_vectorField) -> tmp_vectorField:
        ...
    @typing.overload
    def __add__(self, arg0: vector) -> tmp_vectorField:
        ...
    @typing.overload
    def __and__(self, arg0: vector) -> tmp_scalarField:
        ...
    @typing.overload
    def __and__(self, arg0: vectorField) -> tmp_scalarField:
        ...
    @typing.overload
    def __and__(self, arg0: tensor) -> tmp_vectorField:
        ...
    @typing.overload
    def __and__(self, arg0: tensorField) -> tmp_vectorField:
        ...
    @typing.overload
    def __and__(self, arg0: symmTensor) -> tmp_vectorField:
        ...
    @typing.overload
    def __and__(self, arg0: symmTensorField) -> tmp_vectorField:
        ...
    def __getitem__(self, arg0: typing.SupportsInt) -> vector:
        ...
    @typing.overload
    def __iadd__(self, arg0: vectorField) -> vectorField:
        ...
    @typing.overload
    def __iadd__(self, arg0: tmp_vectorField) -> vectorField:
        ...
    @typing.overload
    def __iadd__(self, arg0: vector) -> vectorField:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: vectorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_vectorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: collections.abc.Sequence[vector]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]) -> None:
        ...
    @typing.overload
    def __isub__(self, arg0: vectorField) -> vectorField:
        ...
    @typing.overload
    def __isub__(self, arg0: tmp_vectorField) -> vectorField:
        ...
    @typing.overload
    def __isub__(self, arg0: vector) -> vectorField:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_vectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: scalarField) -> tmp_vectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_scalarField) -> tmp_vectorField:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: vector) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: vectorField) -> tmp_vectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_vectorField) -> tmp_vectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: vector) -> tmp_vectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_vectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: scalarField) -> tmp_vectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: tmp_scalarField) -> tmp_vectorField:
        ...
class volScalarField:
    @staticmethod
    def from_registry(arg0: fvMesh, arg1: str) -> volScalarField:
        ...
    @staticmethod
    def list_objects(arg0: fvMesh) -> wordList:
        ...
    @staticmethod
    def read_field(arg0: fvMesh, arg1: str) -> volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedScalar) -> tmp_volScalarField:
        ...
    @typing.overload
    def __add__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    def __getitem__(self, arg0: str) -> scalarField:
        ...
    @typing.overload
    def __init__(self, arg0: volScalarField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_volScalarField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Word, arg1: tmp_volScalarField) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_volScalarField:
        ...
    @typing.overload
    def __mul__(self, arg0: volVectorField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_volVectorField) -> tmp_volVectorField:
        ...
    def __neg__(self) -> tmp_volScalarField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    def __rtruediv__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    def __setitem__(self, arg0: str, arg1: scalarField) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedScalar) -> tmp_volScalarField:
        ...
    @typing.overload
    def __sub__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: volScalarField) -> tmp_volScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_volScalarField:
        ...
    @typing.overload
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_volScalarField:
        ...
    @typing.overload
    def assign(self, arg0: volScalarField) -> None:
        ...
    @typing.overload
    def assign(self, arg0: tmp_volScalarField) -> None:
        ...
    def correctBoundaryConditions(self) -> None:
        ...
    def internalField(self) -> scalarField:
        ...
    def mesh(self) -> fvMesh:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    def select(self, arg0: bool) -> Word:
        ...
class volSymmTensorField:
    @staticmethod
    def from_registry(arg0: fvMesh, arg1: str) -> volSymmTensorField:
        ...
    @staticmethod
    def list_objects(arg0: fvMesh) -> wordList:
        ...
    @staticmethod
    def read_field(arg0: fvMesh, arg1: str) -> volSymmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: volSymmTensorField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volSymmTensorField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedSymmTensor) -> tmp_volSymmTensorField:
        ...
    def __getitem__(self, arg0: str) -> symmTensorField:
        ...
    @typing.overload
    def __init__(self, arg0: volSymmTensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_volSymmTensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Word, arg1: tmp_volSymmTensorField) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: volScalarField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_volScalarField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_volSymmTensorField:
        ...
    def __neg__(self) -> tmp_volSymmTensorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_volSymmTensorField:
        ...
    def __setitem__(self, arg0: str, arg1: symmTensorField) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: volSymmTensorField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volSymmTensorField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedSymmTensor) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: volScalarField) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_volSymmTensorField:
        ...
    @typing.overload
    def assign(self, arg0: volSymmTensorField) -> None:
        ...
    @typing.overload
    def assign(self, arg0: tmp_volSymmTensorField) -> None:
        ...
    def correctBoundaryConditions(self) -> None:
        ...
    def internalField(self) -> symmTensorField:
        ...
    def mesh(self) -> fvMesh:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    def select(self, arg0: bool) -> Word:
        ...
class volTensorField:
    @staticmethod
    def from_registry(arg0: fvMesh, arg1: str) -> volTensorField:
        ...
    @staticmethod
    def list_objects(arg0: fvMesh) -> wordList:
        ...
    @staticmethod
    def read_field(arg0: fvMesh, arg1: str) -> volTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: volTensorField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volTensorField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedTensor) -> tmp_volTensorField:
        ...
    def __getitem__(self, arg0: str) -> tensorField:
        ...
    @typing.overload
    def __init__(self, arg0: volTensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_volTensorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Word, arg1: tmp_volTensorField) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: volScalarField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_volScalarField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_volTensorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_volTensorField:
        ...
    def __neg__(self) -> tmp_volTensorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_volTensorField:
        ...
    def __setitem__(self, arg0: str, arg1: tensorField) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: volTensorField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volTensorField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedTensor) -> tmp_volTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: volScalarField) -> tmp_volTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_volTensorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_volTensorField:
        ...
    @typing.overload
    def assign(self, arg0: volTensorField) -> None:
        ...
    @typing.overload
    def assign(self, arg0: tmp_volTensorField) -> None:
        ...
    def correctBoundaryConditions(self) -> None:
        ...
    def internalField(self) -> tensorField:
        ...
    def mesh(self) -> fvMesh:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    def select(self, arg0: bool) -> Word:
        ...
class volVectorField:
    @staticmethod
    def from_registry(arg0: fvMesh, arg1: str) -> volVectorField:
        ...
    @staticmethod
    def list_objects(arg0: fvMesh) -> wordList:
        ...
    @staticmethod
    def read_field(arg0: fvMesh, arg1: str) -> volVectorField:
        ...
    @typing.overload
    def __add__(self, arg0: volVectorField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __add__(self, arg0: tmp_volVectorField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __add__(self, arg0: dimensionedVector) -> tmp_volVectorField:
        ...
    def __getitem__(self, arg0: str) -> vectorField:
        ...
    @typing.overload
    def __init__(self, arg0: volVectorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tmp_volVectorField) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Word, arg1: tmp_volVectorField) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: volScalarField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: tmp_volScalarField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: typing.SupportsFloat) -> tmp_volVectorField:
        ...
    @typing.overload
    def __mul__(self, arg0: dimensionedScalar) -> tmp_volVectorField:
        ...
    def __neg__(self) -> tmp_volVectorField:
        ...
    def __rmul__(self, arg0: typing.SupportsFloat) -> tmp_volVectorField:
        ...
    def __setitem__(self, arg0: str, arg1: vectorField) -> None:
        ...
    @typing.overload
    def __sub__(self, arg0: volVectorField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: tmp_volVectorField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __sub__(self, arg0: dimensionedVector) -> tmp_volVectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: volScalarField) -> tmp_volVectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: typing.SupportsFloat) -> tmp_volVectorField:
        ...
    @typing.overload
    def __truediv__(self, arg0: dimensionedScalar) -> tmp_volVectorField:
        ...
    @typing.overload
    def assign(self, arg0: volVectorField) -> None:
        ...
    @typing.overload
    def assign(self, arg0: tmp_volVectorField) -> None:
        ...
    def correctBoundaryConditions(self) -> None:
        ...
    def internalField(self) -> vectorField:
        ...
    def mesh(self) -> fvMesh:
        ...
    @typing.overload
    def relax(self) -> None:
        ...
    @typing.overload
    def relax(self, arg0: typing.SupportsFloat) -> None:
        ...
    def select(self, arg0: bool) -> Word:
        ...
class wordList:
    def __getitem__(self, arg0: typing.SupportsInt) -> str:
        ...
    @typing.overload
    def __init__(self, arg0: wordList) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: collections.abc.Sequence[str]) -> None:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: typing.SupportsInt, arg1: str) -> None:
        ...
    def list(self) -> list[str]:
        ...
@typing.overload
def Info(arg0: str) -> None:
    ...
@typing.overload
def Info(arg0: dictionary) -> None:
    ...
def adjustPhi(arg0: surfaceScalarField, arg1: volVectorField, arg2: volScalarField) -> bool:
    ...
def computeCFLNumber(arg0: surfaceScalarField) -> tuple[float, float]:
    ...
def computeContinuityErrors(phi: surfaceScalarField) -> tuple[float, float]:
    ...
def constrainHbyA(arg0: tmp_volVectorField, arg1: volVectorField, arg2: volScalarField) -> tmp_volVectorField:
    ...
@typing.overload
def constrainPressure(p: volScalarField, U: volVectorField, phiHbyA: surfaceScalarField, rAU: volScalarField) -> None:
    ...
@typing.overload
def constrainPressure(p: volScalarField, U: volVectorField, phiHbyA: surfaceScalarField, rAU: surfaceScalarField) -> None:
    ...
def createMesh(time: Time, autoWrite: bool = False) -> fvMesh:
    """
    Create a mesh from a Time object
    """
def createPhi(U: volVectorField) -> surfaceScalarField:
    ...
@typing.overload
def mag(arg0: typing.SupportsFloat) -> float:
    ...
@typing.overload
def mag(arg0: vector) -> float:
    ...
@typing.overload
def mag(arg0: tensor) -> float:
    ...
@typing.overload
def mag(arg0: volScalarField) -> tmp_volScalarField:
    ...
@typing.overload
def mag(arg0: volVectorField) -> tmp_volScalarField:
    ...
@typing.overload
def mag(arg0: volTensorField) -> tmp_volScalarField:
    ...
@typing.overload
def mag(arg0: volSymmTensorField) -> tmp_volScalarField:
    ...
@typing.overload
def mag(arg0: surfaceScalarField) -> tmp_surfaceScalarField:
    ...
@typing.overload
def mag(arg0: surfaceVectorField) -> tmp_surfaceScalarField:
    ...
@typing.overload
def mag(arg0: surfaceTensorField) -> tmp_surfaceScalarField:
    ...
def selectTimes(arg0: Time, arg1: collections.abc.Sequence[str]) -> instantList:
    ...
def setRefCell(p: volScalarField, dict: dictionary, forceReference: bool = False) -> tuple[int, float]:
    ...
@typing.overload
def solve(arg0: fvScalarMatrix) -> SolverScalarPerformance:
    ...
@typing.overload
def solve(arg0: tmp_fvScalarMatrix) -> SolverScalarPerformance:
    ...
@typing.overload
def solve(arg0: fvVectorMatrix) -> SolverVectorPerformance:
    ...
@typing.overload
def solve(arg0: tmp_fvVectorMatrix) -> SolverVectorPerformance:
    ...
@typing.overload
def solve(arg0: fvTensorMatrix) -> SolverTensorPerformance:
    ...
@typing.overload
def solve(arg0: tmp_fvTensorMatrix) -> SolverTensorPerformance:
    ...
@typing.overload
def solve(arg0: fvSymmTensorMatrix) -> SolverSymmTensorPerformance:
    ...
@typing.overload
def solve(arg0: tmp_fvSymmTensorMatrix) -> SolverSymmTensorPerformance:
    ...
@typing.overload
def sum(arg0: scalarField) -> float:
    ...
@typing.overload
def sum(arg0: vectorField) -> vector:
    ...
@typing.overload
def sum(arg0: tensorField) -> tensor:
    ...
@typing.overload
def sum(arg0: symmTensorField) -> symmTensor:
    ...
@typing.overload
def write(arg0: volScalarField) -> None:
    ...
@typing.overload
def write(arg0: volVectorField) -> None:
    ...
@typing.overload
def write(arg0: volTensorField) -> None:
    ...
@typing.overload
def write(arg0: volSymmTensorField) -> None:
    ...
@typing.overload
def write(arg0: surfaceScalarField) -> None:
    ...
@typing.overload
def write(arg0: surfaceVectorField) -> None:
    ...
@typing.overload
def write(arg0: surfaceTensorField) -> None:
    ...
@typing.overload
def write(arg0: surfaceSymmTensorField) -> None:
    ...
dimAcceleration: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimArea: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimCurrent: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimDensity: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimEnergy: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimForce: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimLength: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimLuminousIntensity: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimMass: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimMoles: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimPower: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimPressure: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimTemperature: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimTime: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimVelocity: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimViscosity: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
dimless: dimensionSet  # value = <pybFoam.pybFoam_core.dimensionSet object>
